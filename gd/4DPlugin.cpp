/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : GD
 #	author : miyako
 #	2016/09/23
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"
#include "gd.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Filter

		case 1 :
			GD_Filter(pResult, pParams);
			break;

// --- Animation

		case 2 :
			GD_Animate(pResult, pParams);
			break;

// --- Rotation

		case 3 :
			GD_Rotate(pResult, pParams);
			break;

	}
}

#pragma mark -

// ------------------------------------ Filter ------------------------------------


void GD_Filter(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param2;
	C_REAL Param3;
	C_REAL Param4;
	C_REAL Param5;
	C_REAL Param6;
	
	PA_Picture p = *(PA_Picture *)(pParams[0]);
	
	if(p)
	{
		Param2.fromParamAtIndex(pParams, 2);
		Param3.fromParamAtIndex(pParams, 3);
		Param4.fromParamAtIndex(pParams, 4);
		Param5.fromParamAtIndex(pParams, 5);
		Param6.fromParamAtIndex(pParams, 6);
		
		gdImagePtr gd_in = NULL;
		
		CUTF8String codec_u8 = CUTF8String((const uint8_t *)".png");
		uint32_t size = ((uint32_t)codec_u8.length() * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
		std::vector<uint8_t> buf(size);
		uint32_t len = PA_ConvertCharsetToCharset(
																							(char *)codec_u8.c_str(),
																							(uint32_t)codec_u8.length(),
																							eVTC_UTF_8,
																							(char *)&buf[0],
																							size,
																							eVTC_UTF_16
																							);
		CUTF16String codec_u16 = CUTF16String((const PA_Unichar *)&buf[0], len);
		
		/* convert to png */
		p = PA_DuplicatePicture(p, kcpRetainOnly); // disposed each time with PA_ClearVariable
		PA_Variable args[2];
		args[0] = PA_CreateVariable(eVK_Picture);
		PA_SetPictureVariable(&args[0], p);
		
		args[1] = PA_CreateVariable(eVK_Unistring);
		PA_Unistring codec = PA_CreateUnistring((PA_Unichar *)codec_u16.c_str()); // disposed each time with PA_ClearVariable
		PA_SetStringVariable(&args[1], &codec);
		
		PA_ExecuteCommandByID(CMD_CONVERT_PICTURE, args, 2);
		
		p = PA_GetPictureVariable(args[0]); // a new picture is created
		
		PA_Handle h = PA_NewHandle(0);
		PA_GetPictureData(p, 1, h);
		
		if(PA_GetLastError() == eER_NoErr)
		{
			gd_in = gdImageCreateFromPngPtr(PA_GetHandleSize(h), PA_LockHandle(h));
			PA_UnlockHandle(h);
		}
		PA_DisposeHandle(h);
		
		PA_ClearVariable(&args[0]);
		PA_ClearVariable(&args[1]);
		
		if(gd_in) // NULL if image is not PNG
		{
			gdImageSaveAlpha(gd_in, 1);
			
			int len = 0;
			void *bytes = NULL;
			
			switch (Param2.getIntValue())
			{
					// 0 params
				case IMG_FILTER_NEGATE:
					if(GD_TRUE == gdImageNegate(gd_in))
					{
						bytes = gdImagePngPtr(gd_in, &len);
						PA_Picture picture = PA_CreatePicture((void *)bytes, len);
						*(PA_Picture*) pResult = picture;
					}
					break;
				case IMG_FILTER_GRAYSCALE:
					if(GD_TRUE == gdImageGrayScale(gd_in))
					{
						bytes = gdImagePngPtr(gd_in, &len);
						PA_Picture picture = PA_CreatePicture((void *)bytes, len);
						*(PA_Picture*) pResult = picture;
					}
					break;
				case IMG_FILTER_EDGEDETECT:
					if(GD_TRUE == gdImageEdgeDetectQuick(gd_in))
					{
						bytes = gdImagePngPtr(gd_in, &len);
						PA_Picture picture = PA_CreatePicture((void *)bytes, len);
						*(PA_Picture*) pResult = picture;
					}
					break;
				case IMG_FILTER_EMBOSS:
					if(GD_TRUE == gdImageEmboss(gd_in))
					{
						bytes = gdImagePngPtr(gd_in, &len);
						PA_Picture picture = PA_CreatePicture((void *)bytes, len);
						*(PA_Picture*) pResult = picture;
					}
					break;
				case IMG_FILTER_SELECTIVE_BLUR:
					if(GD_TRUE == gdImageSelectiveBlur(gd_in))
					{
						bytes = gdImagePngPtr(gd_in, &len);
						PA_Picture picture = PA_CreatePicture((void *)bytes, len);
						*(PA_Picture*) pResult = picture;
					}
					break;
				case IMG_FILTER_MEAN_REMOVAL:
					if(GD_TRUE == gdImageMeanRemoval(gd_in))
					{
						bytes = gdImagePngPtr(gd_in, &len);
						PA_Picture picture = PA_CreatePicture((void *)bytes, len);
						*(PA_Picture*) pResult = picture;
					}
					break;
					// 1 param
				case IMG_FILTER_SMOOTH:
					if(GD_TRUE == gdImageSmooth(gd_in, (float)Param3.getDoubleValue()))
					{
						bytes = gdImagePngPtr(gd_in, &len);
						PA_Picture picture = PA_CreatePicture((void *)bytes, len);
						*(PA_Picture*) pResult = picture;
					}
					break;
				case IMG_FILTER_CONTRAST:
					if(GD_TRUE == gdImageContrast(gd_in, (double)Param3.getDoubleValue()))
					{
						bytes = gdImagePngPtr(gd_in, &len);
						PA_Picture picture = PA_CreatePicture((void *)bytes, len);
						*(PA_Picture*) pResult = picture;
					}
					break;
				case IMG_FILTER_BRIGHTNESS:
					if(GD_TRUE == gdImageBrightness(gd_in, (int)Param3.getDoubleValue()))
					{
						bytes = gdImagePngPtr(gd_in, &len);
						PA_Picture picture = PA_CreatePicture((void *)bytes, len);
						*(PA_Picture*) pResult = picture;
					}
					break;
					// 2 params
				case IMG_FILTER_SCATTER:
					if(GD_TRUE == gdImageScatter(gd_in, (int)Param3.getDoubleValue(), (int)Param4.getDoubleValue()))
					{
						bytes = gdImagePngPtr(gd_in, &len);
						PA_Picture picture = PA_CreatePicture((void *)bytes, len);
						*(PA_Picture*) pResult = picture;
					}
					break;
				case IMG_FILTER_PIXELATE:
					if(GD_TRUE == gdImagePixelate(gd_in, (int)Param3.getDoubleValue(), (int)Param4.getDoubleValue()))
					{
						bytes = gdImagePngPtr(gd_in, &len);
						PA_Picture picture = PA_CreatePicture((void *)bytes, len);
						*(PA_Picture*) pResult = picture;
					}
					break;
				case IMG_FILTER_GAUSSIAN_BLUR:
				{
					gdImagePtr gd_out = gdImageCopyGaussianBlurred(gd_in, (int)Param3.getDoubleValue(), (double)Param4.getDoubleValue());
					if(gd_out)
					{
						gdImageSaveAlpha(gd_out, 1);
						bytes = gdImagePngPtr(gd_out, &len);
						PA_Picture picture = PA_CreatePicture((void *)bytes, len);
						*(PA_Picture*) pResult = picture;
						gdImageDestroy(gd_out);
					}
				}
					break;
					// 4 params
				case IMG_FILTER_COLORIZE:
					if(GD_TRUE == gdImageColor(gd_in, (int)Param3.getDoubleValue(), (int)Param4.getDoubleValue()
																		 , (int)Param5.getDoubleValue(), (int)Param6.getDoubleValue()))
					{
						bytes = gdImagePngPtr(gd_in, &len);
						PA_Picture picture = PA_CreatePicture((void *)bytes, len);
						*(PA_Picture*) pResult = picture;
					}
					break;
				default:
					break;
			}
			
			gdImageDestroy(gd_in);
		}
	
	}
	
}

// ----------------------------------- Animation ----------------------------------

void GD_Animate(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB result;
	C_LONGINT Param2;
	
	Param2.fromParamAtIndex(pParams, 2);
	unsigned int delay = Param2.getIntValue();
	
	PA_Variable Param1 = *((PA_Variable*) pParams[0]);
	
	if(Param1.fType == eVK_ArrayPicture)
	{
		/* prepare $2 for CONVERT PICTURE */
		CUTF8String codec_u8 = CUTF8String((const uint8_t *)".gif");
		uint32_t size = ((uint32_t)codec_u8.length() * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
		std::vector<uint8_t> buf(size);
		uint32_t len = PA_ConvertCharsetToCharset(
																							(char *)codec_u8.c_str(),
																							(uint32_t)codec_u8.length(),
																							eVTC_UTF_8,
																							(char *)&buf[0],
																							size,
																							eVTC_UTF_16
																							);
		CUTF16String codec_u16 = CUTF16String((const PA_Unichar *)&buf[0], len);
		
		std::vector<gdImagePtr> frames(0);
		
		PA_long32 count = PA_GetArrayNbElements(Param1);
		
		for(PA_long32 i = 0; i <= count; ++i)
		{
			PA_Picture p = PA_GetPictureInArray(Param1, i);
		
			PA_YieldAbsolute();
			
			if(p)
			{
				/* convert to gif */
				p = PA_DuplicatePicture(p, kcpRetainOnly); // disposed each time with PA_ClearVariable
				PA_Variable args[2];
				args[0] = PA_CreateVariable(eVK_Picture);
				PA_SetPictureVariable(&args[0], p);
				
				args[1] = PA_CreateVariable(eVK_Unistring);
				PA_Unistring codec = PA_CreateUnistring((PA_Unichar *)codec_u16.c_str()); // disposed each time with PA_ClearVariable
				PA_SetStringVariable(&args[1], &codec);
				
				PA_ExecuteCommandByID(CMD_CONVERT_PICTURE, args, 2);
				
				p = PA_GetPictureVariable(args[0]); // a new picture is created
				
				PA_Handle h = PA_NewHandle(0);
				PA_GetPictureData(p, 1, h);
				
				if(PA_GetLastError() == eER_NoErr)
				{
					gdImagePtr gd = gdImageCreateFromGifPtr(PA_GetHandleSize(h), PA_LockHandle(h));
					PA_UnlockHandle(h);
					
					if(gd) // NULL if image is not GIF
					{
						frames.push_back(gd);
					}
					
				}
				PA_DisposeHandle(h);
				
				PA_ClearVariable(&args[0]);
				PA_ClearVariable(&args[1]);
			}
			
		}
		
		/* create animation gif */
		if(frames.size())
		{
			int len = 0;
			void *bytes = NULL;
						
			bytes = gdImageGifAnimBeginPtr(frames[0], &len, 1, gdLoopInfinite);
			result.addBytes((const uint8_t *)bytes, len);
			gdFree(bytes);
			
			for(size_t i = 0; i < frames.size(); ++i)
			{
				PA_YieldAbsolute();
				bytes = gdImageGifAnimAddPtr(frames[i], &len, 1, 0, 0, delay,
																		 i == 0 ? gdDisposalNone : gdDisposalRestorePrevious,
																		 i == 0 ? NULL : frames[i-1]);
				result.addBytes((const uint8_t *)bytes, len);
				gdFree(bytes);
			}
			
			bytes = gdImageGifAnimEndPtr(&len);
			result.addBytes((const uint8_t *)bytes, len);
			gdFree(bytes);

			for(size_t i = 0; i < frames.size(); ++i)
			{
				PA_YieldAbsolute();
				gdImageDestroy(frames[i]);
			}
			
			PA_Picture picture = PA_CreatePicture((void *)result.getBytesPtr(), result.getBytesLength());
			*(PA_Picture*) pResult = picture;
			
		}

	}

}

// ----------------------------------- Rotation -----------------------------------

#pragma mark -

bool getPictureDataForType(PackagePtr pParams, int index, std::vector<unsigned char> &buf, std::string &type)
{
	PA_ErrorCode err = eER_NoErr;
	unsigned i = 0;
	PA_Unistring t;
	std::map<CUTF8String, uint32_t> types;
	PA_Picture picture = *(PA_Picture *)(pParams[index - 1]);
	while (err == eER_NoErr)
	{
		t = PA_GetPictureData(picture, ++i, NULL);
		err = PA_GetLastError();
		if(err == eER_NoErr)
		{
			uint32_t len = (uint32_t)(t.fLength * 4) + sizeof(uint8_t);
			std::vector<uint8_t> u(len);
			PA_ConvertCharsetToCharset(
																 (char *)t.fString,
																 t.fLength * sizeof(PA_Unichar),
																 eVTC_UTF_16,
																 (char *)&u[0],
																 len,
																 eVTC_UTF_8
																 );
			CUTF8String uti;
			uti = CUTF8String((const uint8_t *)&u[0]);
			CUTF8String typestring;
			size_t pos, found;
			found = 0;
			for(pos = uti.find(';'); pos != CUTF8String::npos; pos = uti.find(';', found))
			{
				typestring = uti.substr(found, pos-found);
				found = pos + 1;
				types.insert(std::map<CUTF8String, uint32_t>::value_type(typestring, i));
			}
			typestring = uti.substr(found, uti.length()-found);
			types.insert(std::map<CUTF8String, uint32_t>::value_type(typestring, i));
		}
	}
	std::map<CUTF8String, uint32_t>::iterator itr;
	itr = types.find((const uint8_t *)type.c_str());
	if (itr != types.end())
	{
		uint32_t pos = itr->second;
		PA_Handle h = PA_NewHandle(0);
		err = eER_NoErr;
		PA_GetPictureData(picture, pos, h);
		err = PA_GetLastError();
		if(err == eER_NoErr)
		{
			unsigned long insize = PA_GetHandleSize(h);
			buf.resize(insize);
			memcpy(&buf[0], (const void *)PA_LockHandle(h), insize);
			PA_UnlockHandle(h);
			PA_DisposeHandle(h);
			return true;
		}
	}
	return false;
}

#pragma mark -

void GD_Rotate(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param2;
	Param2.fromParamAtIndex(pParams, 2);
	int angle = Param2.getIntValue();
	
	PA_Picture p = *(PA_Picture *)(pParams[0]);
	
	if(p)
	{
		gdImagePtr gd_in = NULL;
		
		CUTF8String codec_u8 = CUTF8String((const uint8_t *)".png");
		uint32_t size = ((uint32_t)codec_u8.length() * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
		std::vector<uint8_t> buf(size);
		uint32_t len = PA_ConvertCharsetToCharset(
																							(char *)codec_u8.c_str(),
																							(uint32_t)codec_u8.length(),
																							eVTC_UTF_8,
																							(char *)&buf[0],
																							size,
																							eVTC_UTF_16
																							);
		CUTF16String codec_u16 = CUTF16String((const PA_Unichar *)&buf[0], len);
		
		/* convert to png */
		p = PA_DuplicatePicture(p, kcpRetainOnly); // disposed each time with PA_ClearVariable
		PA_Variable args[2];
		args[0] = PA_CreateVariable(eVK_Picture);
		PA_SetPictureVariable(&args[0], p);
		
		args[1] = PA_CreateVariable(eVK_Unistring);
		PA_Unistring codec = PA_CreateUnistring((PA_Unichar *)codec_u16.c_str()); // disposed each time with PA_ClearVariable
		PA_SetStringVariable(&args[1], &codec);
		
		PA_ExecuteCommandByID(CMD_CONVERT_PICTURE, args, 2);
		
		p = PA_GetPictureVariable(args[0]); // a new picture is created
		
		PA_Handle h = PA_NewHandle(0);
		PA_GetPictureData(p, 1, h);
		
		if(PA_GetLastError() == eER_NoErr)
		{
			gd_in = gdImageCreateFromPngPtr(PA_GetHandleSize(h), PA_LockHandle(h));
			PA_UnlockHandle(h);
		}
		PA_DisposeHandle(h);
		
		PA_ClearVariable(&args[0]);
		PA_ClearVariable(&args[1]);
		
		if(gd_in) // NULL if image is not PNG
		{

			gdImagePtr gd_out = gdImageCreateTrueColor(gdImageSX(gd_in), gdImageSY(gd_in));
			
			if(gd_out)
			{
				/* make background transparent */
				gdImageAlphaBlending(gd_out, 0);
				gdImageFill(gd_out, 0, 0, gdImageColorAllocateAlpha(gd_out, 0, 0, 0, 255));
				gdImageSaveAlpha(gd_out, 1);
				
				int len = 0;
				void *bytes = NULL;
				
				gdImageCopyRotated(gd_out, gd_in,
													 gdImageSX(gd_out)/2, // dstX
													 gdImageSY(gd_out)/2, // dstY
													 0, // srcX
													 0, // srcY
													 gdImageSX(gd_in), // srcWidth
													 gdImageSY(gd_in), // srcHeight
													 angle);
			
				bytes = gdImagePngPtr(gd_out, &len);
				PA_Picture picture = PA_CreatePicture((void *)bytes, len);
				*(PA_Picture*) pResult = picture;
				
				gdImageDestroy(gd_out);
			}
			gdImageDestroy(gd_in);
		}
		
	}
	
}

